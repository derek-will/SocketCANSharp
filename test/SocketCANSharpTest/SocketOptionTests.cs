#region License
/* 
BSD 3-Clause License

Copyright (c) 2021, Derek Will
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/
#endregion

using NUnit.Framework;
using SocketCANSharp;
using SocketCANSharp.Network.Netlink;
using System;
using System.Net.Sockets;
using System.Runtime.InteropServices;

namespace SocketCANSharpTest
{
    public class SocketOptionTests
    {
        SafeFileDescriptorHandle socketHandle;

        [TearDown]
        public void Cleanup()
        {
            socketHandle.Close();
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_FILTER_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var canFilter1 = new CanFilter(0x700, 0x700);
            var canFilter2 = new CanFilter(0x600, 0x600);
            var canFilterArray = new CanFilter[] { canFilter1, canFilter2 };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FILTER, canFilterArray, Marshal.SizeOf(typeof(CanFilter)) * canFilterArray.Length);
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_FILTER_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var canFilter1 = new CanFilter(0x700, 0x700);
            var canFilter2 = new CanFilter(0x600, 0x600);
            var canFilterArray = new CanFilter[] { canFilter1, canFilter2 };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FILTER, canFilterArray, Marshal.SizeOf(typeof(CanFilter)) * canFilterArray.Length);
            Assert.AreEqual(0, result);

            canFilterArray = new CanFilter[] { new CanFilter(), new CanFilter() };
            int len = Marshal.SizeOf(typeof(CanFilter)) * canFilterArray.Length;
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FILTER, canFilterArray, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(2, canFilterArray.Length);
            Assert.AreEqual(0x700, canFilterArray[0].CanId);
            Assert.AreEqual(0x700, canFilterArray[0].CanMask);
            Assert.AreEqual(0x600, canFilterArray[1].CanId);
            Assert.AreEqual(0x600, canFilterArray[1].CanMask);
        }

        [Test]
        public void SocketOption_CAN_RAW_FILTER_via_IntPtr_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var canFilter1 = new CanFilter(0x700, 0x700);
            var canFilter2 = new CanFilter(0x600, 0x600);
            var canFilterArray = new CanFilter[] { canFilter1, canFilter2 };

            int size = Marshal.SizeOf(typeof(CanFilter));
            IntPtr ptr = Marshal.AllocHGlobal(size * canFilterArray.Length);
            try
            {
                IntPtr iteratorPtr = ptr;
                for (int i = 0; i < canFilterArray.Length; ++i)
                {
                    Marshal.StructureToPtr<CanFilter>(canFilterArray[i], iteratorPtr, false);
                    iteratorPtr = IntPtr.Add(iteratorPtr, size);
                }

                int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, (int)CanSocketOptions.CAN_RAW_FILTER, ptr, size * canFilterArray.Length);
                Assert.AreEqual(0, result);
            }
            finally
            {
                Marshal.FreeHGlobal(ptr);
            }

            int len = size * (int)SocketCanConstants.CAN_RAW_FILTER_MAX;
            ptr = Marshal.AllocHGlobal(len);
            try
            {
                int result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, (int)CanSocketOptions.CAN_RAW_FILTER, ptr, ref len);
                Assert.AreEqual(0, result);

                canFilterArray = new CanFilter[len / size];
                IntPtr iteratorPtr = ptr;
                for (int i = 0; i < canFilterArray.Length; ++i)
                {
                    canFilterArray[i] = Marshal.PtrToStructure<CanFilter>(iteratorPtr);
                    iteratorPtr = IntPtr.Add(iteratorPtr, size);
                }
            }
            finally
            {
                Marshal.FreeHGlobal(ptr);
            }

            Assert.AreEqual(2, canFilterArray.Length);
            Assert.AreEqual(0x700, canFilterArray[0].CanId);
            Assert.AreEqual(0x700, canFilterArray[0].CanMask);
            Assert.AreEqual(0x600, canFilterArray[1].CanId);
            Assert.AreEqual(0x600, canFilterArray[1].CanMask);
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_ERR_FILTER_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            uint err_mask = ((uint)CanErrorClass.CAN_ERR_TX_TIMEOUT | (uint)CanErrorClass.CAN_ERR_BUSOFF);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_ERR_FILTER, ref err_mask, Marshal.SizeOf(err_mask));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_ERR_FILTER_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            uint err_mask = ((uint)CanErrorClass.CAN_ERR_TX_TIMEOUT | (uint)CanErrorClass.CAN_ERR_BUSOFF);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_ERR_FILTER, ref err_mask, Marshal.SizeOf(err_mask));
            Assert.AreEqual(0, result);

            err_mask = 0;
            int len = Marshal.SizeOf(err_mask);
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_ERR_FILTER, ref err_mask, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual((uint)CanErrorClass.CAN_ERR_TX_TIMEOUT | (uint)CanErrorClass.CAN_ERR_BUSOFF, err_mask);
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_LOOPBACK_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int loopback = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_LOOPBACK, ref loopback, Marshal.SizeOf(loopback));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_LOOPBACK_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int loopback = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_LOOPBACK, ref loopback, Marshal.SizeOf(loopback));
            Assert.AreEqual(0, result);

            loopback = 0;
            int len = Marshal.SizeOf(loopback);
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_LOOPBACK, ref loopback, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(1, loopback);
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_RECV_OWN_MSGS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int recv_own_msgs = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_RECV_OWN_MSGS, ref recv_own_msgs, Marshal.SizeOf(recv_own_msgs));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_RECV_OWN_MSGS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int recv_own_msgs = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_RECV_OWN_MSGS, ref recv_own_msgs, Marshal.SizeOf(recv_own_msgs));
            Assert.AreEqual(0, result);

            recv_own_msgs = 0;
            int len = Marshal.SizeOf(recv_own_msgs);
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_RECV_OWN_MSGS, ref recv_own_msgs, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(1, recv_own_msgs);
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_FD_FRAMES_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var ifr = new Ifreq("vcan0");
            int ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFINDEX, ifr);
            Assert.AreNotEqual(-1, ioctlResult);

            var ifrMtu = new IfreqMtu("vcan0");
            ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFMTU, ifrMtu);
            Assert.AreNotEqual(-1, ioctlResult, $"Errno: {LibcNativeMethods.Errno}");
            Assume.That(ifrMtu.MTU, Is.GreaterThanOrEqualTo(SocketCanConstants.CANFD_MTU));

            int can_fd_enabled = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FD_FRAMES, ref can_fd_enabled, Marshal.SizeOf(can_fd_enabled));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_FD_FRAMES_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var ifr = new Ifreq("vcan0");
            int ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFINDEX, ifr);
            Assert.AreNotEqual(-1, ioctlResult);

            var ifrMtu = new IfreqMtu("vcan0");
            ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFMTU, ifrMtu);
            Assert.AreNotEqual(-1, ioctlResult, $"Errno: {LibcNativeMethods.Errno}");
            Assume.That(ifrMtu.MTU, Is.GreaterThanOrEqualTo(SocketCanConstants.CANFD_MTU));

            int can_fd_enabled = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FD_FRAMES, ref can_fd_enabled, Marshal.SizeOf(can_fd_enabled));
            Assert.AreEqual(0, result);

            can_fd_enabled = 0;
            int len = Marshal.SizeOf(can_fd_enabled);
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FD_FRAMES, ref can_fd_enabled, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(1, can_fd_enabled);
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_XL_FRAMES_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var ifr = new Ifreq("vcan0");
            int ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFINDEX, ifr);
            Assert.AreNotEqual(-1, ioctlResult);

            var ifrMtu = new IfreqMtu("vcan0");
            ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFMTU, ifrMtu);
            Assert.AreNotEqual(-1, ioctlResult, $"Errno: {LibcNativeMethods.Errno}");
            Assume.That(ifrMtu.MTU, Is.GreaterThanOrEqualTo(SocketCanConstants.CANXL_MTU));

            int can_xl_enabled = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_XL_FRAMES, ref can_xl_enabled, Marshal.SizeOf(can_xl_enabled));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_XL_FRAMES_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var ifr = new Ifreq("vcan0");
            int ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFINDEX, ifr);
            Assert.AreNotEqual(-1, ioctlResult);

            var ifrMtu = new IfreqMtu("vcan0");
            ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFMTU, ifrMtu);
            Assert.AreNotEqual(-1, ioctlResult, $"Errno: {LibcNativeMethods.Errno}");
            Assume.That(ifrMtu.MTU, Is.GreaterThanOrEqualTo(SocketCanConstants.CANXL_MTU));

            int can_xl_enabled = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_XL_FRAMES, ref can_xl_enabled, Marshal.SizeOf(can_xl_enabled));
            Assert.AreEqual(0, result);

            can_xl_enabled = 0;
            int len = Marshal.SizeOf(can_xl_enabled);
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_XL_FRAMES, ref can_xl_enabled, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(1, can_xl_enabled);
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_JOIN_FILTERS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var canFilter1 = new CanFilter(0x700, 0x700);
            var canFilter2 = new CanFilter(0x600, 0x600);
            var canFilterArray = new CanFilter[] { canFilter1, canFilter2 };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FILTER, canFilterArray, Marshal.SizeOf(typeof(CanFilter)) * canFilterArray.Length);
            Assert.AreEqual(0, result);
            int join_filter = 1;
            result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_JOIN_FILTERS, ref join_filter, Marshal.SizeOf(join_filter));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_JOIN_FILTERS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var canFilter1 = new CanFilter(0x700, 0x700);
            var canFilter2 = new CanFilter(0x600, 0x600);
            var canFilterArray = new CanFilter[] { canFilter1, canFilter2 };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_FILTER, canFilterArray, Marshal.SizeOf(typeof(CanFilter)) * canFilterArray.Length);
            Assert.AreEqual(0, result);
            int join_filter = 1;
            result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_JOIN_FILTERS, ref join_filter, Marshal.SizeOf(join_filter));
            Assert.AreEqual(0, result);

            join_filter = 0;
            int len = Marshal.SizeOf(join_filter);
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_JOIN_FILTERS, ref join_filter, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(1, join_filter);
        }

        [Test]
        public void SocketOption_Set_SO_SNDTIMEO_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var timeval = new Timeval(0, 1);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_SNDTIMEO, timeval, Marshal.SizeOf(typeof(Timeval)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_SNDTIMEO_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var timeval = new Timeval(2, 100000);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_SNDTIMEO, timeval, Marshal.SizeOf(typeof(Timeval)));
            Assert.AreEqual(0, result);

            timeval = new Timeval(0, 0);
            int len = Marshal.SizeOf(typeof(Timeval));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_SNDTIMEO, timeval, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(Environment.Is64BitProcess ? 16 : 8, len);
            Assert.AreEqual(100000, timeval.Microseconds);
            Assert.AreEqual(2, timeval.Seconds);
        }

        [Test]
        public void SocketOption_Set_SO_RCVTIMEO_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var timeval = new Timeval(0, 1);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_RCVTIMEO, timeval, Marshal.SizeOf(typeof(Timeval)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_RCVTIMEO_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var timeval = new Timeval(3, 0);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_RCVTIMEO, timeval, Marshal.SizeOf(typeof(Timeval)));
            Assert.AreEqual(0, result);

            timeval = new Timeval(0, 0);
            int len = Marshal.SizeOf(typeof(Timeval));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_RCVTIMEO, timeval, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(Environment.Is64BitProcess ? 16 : 8, len);
            Assert.AreEqual(0, timeval.Microseconds);
            Assert.AreEqual(3, timeval.Seconds);
        }

        [Test]
        public void SocketOption_Set_CAN_ISOTP_OPTS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var canIsoTpOpts = new CanIsoTpOptions()
            {
                Flags = IsoTpFlags.CAN_ISOTP_TX_PADDING | IsoTpFlags.CAN_ISOTP_WAIT_TX_DONE,
                TxPadByte = 0xDD,
            };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_OPTS, canIsoTpOpts, Marshal.SizeOf(typeof(CanIsoTpOptions)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_ISOTP_OPTS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var canIsoTpOpts = new CanIsoTpOptions()
            {
                Flags = IsoTpFlags.CAN_ISOTP_TX_PADDING | IsoTpFlags.CAN_ISOTP_WAIT_TX_DONE,
                TxPadByte = 0xDD,
            };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_OPTS, canIsoTpOpts, Marshal.SizeOf(typeof(CanIsoTpOptions)));
            Assert.AreEqual(0, result);

            canIsoTpOpts = new CanIsoTpOptions();
            int len = Marshal.SizeOf(typeof(CanIsoTpOptions));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_OPTS, canIsoTpOpts, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(12, len);
            Assert.AreEqual(IsoTpFlags.CAN_ISOTP_TX_PADDING | IsoTpFlags.CAN_ISOTP_WAIT_TX_DONE, canIsoTpOpts.Flags);
            Assert.AreEqual(0xDD, canIsoTpOpts.TxPadByte);
        }

        [Test]
        public void SocketOption_Set_CAN_ISOTP_RECV_FC_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var canIsoTpFcOpts = new CanIsoTpFlowControlOptions()
            {
                BlockSize = 2,
                Stmin = 10,
                WftMax = 60,
            };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_RECV_FC, canIsoTpFcOpts, Marshal.SizeOf(typeof(CanIsoTpFlowControlOptions)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_ISOTP_RECV_FC_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var canIsoTpFcOpts = new CanIsoTpFlowControlOptions()
            {
                BlockSize = 2,
                Stmin = 10,
                WftMax = 60,
            };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_RECV_FC, canIsoTpFcOpts, Marshal.SizeOf(typeof(CanIsoTpFlowControlOptions)));
            Assert.AreEqual(0, result);

            canIsoTpFcOpts = new CanIsoTpFlowControlOptions();
            int len = Marshal.SizeOf(typeof(CanIsoTpFlowControlOptions));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_RECV_FC, canIsoTpFcOpts, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual((byte)2, canIsoTpFcOpts.BlockSize);
            Assert.AreEqual((byte)10, canIsoTpFcOpts.Stmin);
            Assert.AreEqual((byte)60, canIsoTpFcOpts.WftMax);
        }

        [Test]
        public void SocketOption_Set_CAN_ISOTP_TX_STMIN_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            uint stmin = 100;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_TX_STMIN, ref stmin, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_ISOTP_TX_STMIN_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            uint stmin = 100;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_TX_STMIN, ref stmin, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            stmin = 0;
            int len = Marshal.SizeOf(typeof(int));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_TX_STMIN, ref stmin, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(100, stmin);
            Assert.AreEqual(4, len);
        }

        [Test]
        public void SocketOption_Set_CAN_ISOTP_RX_STMIN_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            uint stmin = 100;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_RX_STMIN, ref stmin, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_ISOTP_RX_STMIN_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            uint stmin = 100;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_RX_STMIN, ref stmin, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            stmin = 0;
            int len = Marshal.SizeOf(typeof(int));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_RX_STMIN, ref stmin, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(100, stmin);
            Assert.AreEqual(4, len);
        }

        [Test]
        public void SocketOption_Set_CAN_ISOTP_LL_OPTS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var canIsoTpLlOpts = new CanIsoTpLinkLayerOptions(16, 8);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_LL_OPTS, canIsoTpLlOpts, Marshal.SizeOf(typeof(CanIsoTpLinkLayerOptions)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_ISOTP_LL_OPTS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_ISOTP);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var canIsoTpLlOpts = new CanIsoTpLinkLayerOptions(16, 8);
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_LL_OPTS, canIsoTpLlOpts, Marshal.SizeOf(typeof(CanIsoTpLinkLayerOptions)));
            Assert.AreEqual(0, result);

            canIsoTpLlOpts = new CanIsoTpLinkLayerOptions();
            int len = Marshal.SizeOf(typeof(CanIsoTpLinkLayerOptions));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_ISOTP, CanIsoTpSocketOptions.CAN_ISOTP_LL_OPTS, canIsoTpLlOpts, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(16, canIsoTpLlOpts.Mtu);
            Assert.AreEqual(8, canIsoTpLlOpts.TxDataLength);
        }

        [Test]
        public void SocketOption_Set_SO_J1939_PROMISC_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int enable = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_PROMISC, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(1, result);

            enable = 0;
            result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_PROMISC, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_J1939_PROMISC_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int enable = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_PROMISC, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(1, result);

            int len = Marshal.SizeOf(typeof(int));
            enable = 0;
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_PROMISC, ref enable, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(4, len);
            Assert.AreEqual(1, enable);

            enable = 0;
            result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_PROMISC, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_PROMISC, ref enable, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(4, len);
            Assert.AreEqual(0, enable);
        }

        [Test]
        public void SocketOption_Set_SO_J1939_FILTER_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var filter = new J1939Filter()
            {
                Name = 0x00000000,
                NameMask = 0xFFFFFFFFFFFFFFFF,
                PGN = 0x40000,
                PGNMask = 0xFFFFFFFF,
                Address = 0xFF,
                AddressMask = 0xFF,
            };

            var filters = new J1939Filter[] { filter };
            var optionValueSize = Marshal.SizeOf(typeof(J1939Filter)) * filters.Length;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_FILTER, filters, optionValueSize);
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_J1939_FILTER_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            var filter = new J1939Filter()
            {
                Name = 0x00000000,
                NameMask = 0xFFFFFFFFFFFFFFFF,
                PGN = 0x40000,
                PGNMask = 0xFFFFFFFF,
                Address = 0xFF,
                AddressMask = 0xFF,
            };

            var filters = new J1939Filter[] { filter };
            var optionValueSize = Marshal.SizeOf(typeof(J1939Filter)) * filters.Length;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_FILTER, filters, optionValueSize);
            Assert.AreEqual(0, result);

            filters = new J1939Filter[] { new J1939Filter() };
            optionValueSize = Marshal.SizeOf(typeof(J1939Filter)) * filters.Length;
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_FILTER, filters, ref optionValueSize);
            Assert.AreEqual(-1, result); // per net/can/j1939/socket.c --> This option name is not supported by getsockopt
            Assert.AreEqual(92, LibcNativeMethods.Errno); // ENOPROTOOPT
        }

        [Test]
        public void SocketOption_Set_SO_J1939_SEND_PRIO_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int prio = 4;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_SEND_PRIO, ref prio, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(result, 0);
        }

        [Test]
        public void SocketOption_Get_SO_J1939_SEND_PRIO_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int prio = 4;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_SEND_PRIO, ref prio, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(result, 0);

            int len = Marshal.SizeOf(typeof(int));
            prio = 0;
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_SEND_PRIO, ref prio, ref len);
            Assert.AreEqual(result, 0);
            Assert.AreEqual(4, prio);
            Assert.AreEqual(4, len);
        }

        [Test]
        public void SocketOption_Set_SO_J1939_ERRQUEUE_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int enable = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_ERRQUEUE, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(1, result);

            enable = 0;
            result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_ERRQUEUE, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_J1939_ERRQUEUE_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int enable = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_ERRQUEUE, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(1, result);

            int len = Marshal.SizeOf(typeof(int));
            enable = 0;
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_ERRQUEUE, ref enable, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(4, len);
            Assert.AreEqual(1, enable);

            enable = 0;
            result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_ERRQUEUE, ref enable, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            len = Marshal.SizeOf(typeof(int));
            enable = 1;
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_J1939, J1939SocketOptions.SO_J1939_ERRQUEUE, ref enable, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(4, len);
            Assert.AreEqual(0, enable);
        }

        [Test]
        public void SocketOption_Set_SO_BROADCAST_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int value = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_BROADCAST, ref value, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_BROADCAST_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Dgram, SocketCanProtocolType.CAN_J1939);
            if (socketHandle.IsInvalid)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(93) & Is.Not.EqualTo(22)); // If EPROTONOSUPPORT, then this protocol is not supported on this platform and not futher testing applies. If EINVAL, then Protocol Type is not being recognized.
            }
            Assert.IsFalse(socketHandle.IsInvalid);

            int value = 1;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_BROADCAST, ref value, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            value = 0;
            int len = Marshal.SizeOf(typeof(int));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_BROADCAST, ref value, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(1, value);
            Assert.AreEqual(4, len);
        }

        [Test]
        public void SocketOption_Set_SO_SNDBUF_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int value = 8192;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_SNDBUF, ref value, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_SNDBUF_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int value = 8192;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_SNDBUF, ref value, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            value = 0;
            int len = Marshal.SizeOf(typeof(int));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_SNDBUF, ref value, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(16384, value); // the kernel doubles whatever we send it in setsockopt and this doubled value is what is returned by getsockopt
            Assert.AreEqual(4, len);
        }

        [Test]
        public void SocketOption_Set_SO_RCVBUF_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int value = 8192;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_RCVBUF, ref value, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_SO_RCVBUF_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            int value = 8192;
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_RCVBUF, ref value, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            value = 0;
            int len = Marshal.SizeOf(typeof(int));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_RCVBUF, ref value, ref len);
            Assert.AreEqual(0, result);
            Assert.AreEqual(16384, value); // the kernel doubles whatever we send it in setsockopt and this doubled value is what is returned by getsockopt
            Assert.AreEqual(4, len);
        }

        [Test]
        public void Netlink_Set_Send_And_Receive_Buffer_Sizes_Test()
        {
            socketHandle = NetlinkNativeMethods.Socket(NetlinkConstants.PF_NETLINK, SocketType.Raw, NetlinkProtocolType.NETLINK_ROUTE);
            Assert.IsFalse(socketHandle.IsInvalid);

            int sendBufferSize = 32768;
            int recvBufferSize = 32768;

            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_SNDBUF, ref sendBufferSize, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);

            result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_SOCKET, SocketLevelOptions.SO_RCVBUF, ref recvBufferSize, Marshal.SizeOf(typeof(int)));
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Set_CAN_RAW_XL_VCID_OPTS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var ifr = new Ifreq("vcan0");
            int ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFINDEX, ifr);
            Assert.AreNotEqual(-1, ioctlResult);

            var ifrMtu = new IfreqMtu("vcan0");
            ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFMTU, ifrMtu);
            Assert.AreNotEqual(-1, ioctlResult, $"Errno: {LibcNativeMethods.Errno}");
            Assume.That(ifrMtu.MTU, Is.GreaterThanOrEqualTo(SocketCanConstants.CANXL_MTU));

            var vcidOptions = new CanRawVcidOptions()
            {
                Flags = CanXlVcidHandlingOption.CAN_RAW_XL_VCID_TX_SET | CanXlVcidHandlingOption.CAN_RAW_XL_VCID_RX_FILTER,
                TxVCID = 0x99,
                RxVCID = 0xC0,
                RxVCIDMask = 0xF0,
            };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_XL_VCID_OPTS, vcidOptions, Marshal.SizeOf(typeof(CanRawVcidOptions)));
            if (result != 0)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(92)); // ENOPROTOOPT - Supported in Kernel 6.9 and higher.
            }
            Assert.AreEqual(0, result);
        }

        [Test]
        public void SocketOption_Get_CAN_RAW_XL_VCID_OPTS_Test()
        {
            socketHandle = LibcNativeMethods.Socket(SocketCanConstants.PF_CAN, SocketType.Raw, SocketCanProtocolType.CAN_RAW);
            Assert.IsFalse(socketHandle.IsInvalid);

            var ifr = new Ifreq("vcan0");
            int ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFINDEX, ifr);
            Assert.AreNotEqual(-1, ioctlResult);

            var ifrMtu = new IfreqMtu("vcan0");
            ioctlResult = LibcNativeMethods.Ioctl(socketHandle, SocketCanConstants.SIOCGIFMTU, ifrMtu);
            Assert.AreNotEqual(-1, ioctlResult, $"Errno: {LibcNativeMethods.Errno}");
            Assume.That(ifrMtu.MTU, Is.GreaterThanOrEqualTo(SocketCanConstants.CANXL_MTU));

            var vcidOptions = new CanRawVcidOptions()
            {
                Flags = CanXlVcidHandlingOption.CAN_RAW_XL_VCID_TX_SET | CanXlVcidHandlingOption.CAN_RAW_XL_VCID_RX_FILTER,
                TxVCID = 0x99,
                RxVCID = 0xC0,
                RxVCIDMask = 0xF0,
            };
            int result = LibcNativeMethods.SetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_XL_VCID_OPTS, vcidOptions, Marshal.SizeOf(typeof(CanRawVcidOptions)));
            if (result != 0)
            {
                Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(92)); // ENOPROTOOPT - Supported in Kernel 6.9 and higher.
            }
            Assert.AreEqual(0, result);

            var vcidOptionsGet = new CanRawVcidOptions();
            int len = Marshal.SizeOf(typeof(CanRawVcidOptions));
            result = LibcNativeMethods.GetSockOpt(socketHandle, SocketLevel.SOL_CAN_RAW, CanSocketOptions.CAN_RAW_XL_VCID_OPTS, vcidOptionsGet, ref len);
            Assume.That(LibcNativeMethods.Errno, Is.Not.EqualTo(42));
            Assert.AreEqual(0, result);
            Assert.IsTrue(vcidOptionsGet.Flags.HasFlag(CanXlVcidHandlingOption.CAN_RAW_XL_VCID_TX_SET));
            Assert.IsFalse(vcidOptionsGet.Flags.HasFlag(CanXlVcidHandlingOption.CAN_RAW_XL_VCID_TX_PASS));
            Assert.IsTrue(vcidOptionsGet.Flags.HasFlag(CanXlVcidHandlingOption.CAN_RAW_XL_VCID_RX_FILTER));
            Assert.AreEqual(0x99, vcidOptionsGet.TxVCID);
            Assert.AreEqual(0xC0, vcidOptionsGet.RxVCID);
            Assert.AreEqual(0xF0, vcidOptionsGet.RxVCIDMask);
        }
    }
}